-- ENUM types for data integrity
-- Note: Supabase might require running CREATE TYPE statements separately if they don't already exist.
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'report_status') THEN
        CREATE TYPE report_status AS ENUM ('pending', 'verified', 'rejected', 'suspicious');
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'priority_level') THEN
        CREATE TYPE priority_level AS ENUM ('low', 'medium', 'high', 'critical');
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'disaster_status') THEN
        CREATE TYPE disaster_status AS ENUM ('active', 'resolved', 'monitoring');
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'resource_status') THEN
        CREATE TYPE resource_status AS ENUM ('available', 'in-use', 'unavailable');
    END IF;
END$$;


-- Trigger function for updated_at
CREATE OR REPLACE FUNCTION trigger_set_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Disasters table
CREATE TABLE IF NOT EXISTS disasters (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  title TEXT NOT NULL,
  location_name TEXT,
  description TEXT,
  tags TEXT[],
  owner_id TEXT NOT NULL,
  location GEOGRAPHY(Point, 4326),
  status disaster_status DEFAULT 'active',
  priority priority_level DEFAULT 'medium',
  verification_status report_status DEFAULT 'pending',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
CREATE INDEX IF NOT EXISTS disasters_location_gix ON disasters USING GIST (location);
CREATE INDEX IF NOT EXISTS disasters_tags_idx ON disasters USING GIN (tags);

DROP TRIGGER IF EXISTS set_disasters_timestamp ON disasters;
CREATE TRIGGER set_disasters_timestamp
BEFORE UPDATE ON disasters
FOR EACH ROW
EXECUTE PROCEDURE trigger_set_timestamp();

ALTER TABLE disasters ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Disasters are publicly viewable." ON disasters;
CREATE POLICY "Disasters are publicly viewable." ON disasters FOR SELECT USING (true);
DROP POLICY IF EXISTS "Users can create disasters." ON disasters;
CREATE POLICY "Users can create disasters." ON disasters FOR INSERT WITH CHECK (true);
DROP POLICY IF EXISTS "Users can update their own disasters." ON disasters;
CREATE POLICY "Users can update their own disasters." ON disasters FOR UPDATE USING (true);
DROP POLICY IF EXISTS "Users can delete their own disasters." ON disasters;
CREATE POLICY "Users can delete their own disasters." ON disasters FOR DELETE USING (true);


-- Reports table
CREATE TABLE IF NOT EXISTS reports (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  disaster_id BIGINT REFERENCES disasters(id) ON DELETE CASCADE NOT NULL,
  user_id TEXT NOT NULL,
  content TEXT NOT NULL,
  image_url TEXT,
  verification_status report_status DEFAULT 'pending',
  priority priority_level DEFAULT 'medium',
  location_name TEXT,
  location GEOGRAPHY(Point, 4326),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
CREATE INDEX IF NOT EXISTS reports_disaster_id_idx ON reports(disaster_id);
CREATE INDEX IF NOT EXISTS reports_location_gix ON reports USING GIST (location);

DROP TRIGGER IF EXISTS set_reports_timestamp ON reports;
CREATE TRIGGER set_reports_timestamp
BEFORE UPDATE ON reports
FOR EACH ROW
EXECUTE PROCEDURE trigger_set_timestamp();

ALTER TABLE reports ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Reports are publicly viewable." ON reports;
CREATE POLICY "Reports are publicly viewable." ON reports FOR SELECT USING (true);
DROP POLICY IF EXISTS "Users can create reports." ON reports;
CREATE POLICY "Users can create reports." ON reports FOR INSERT WITH CHECK (true);
DROP POLICY IF EXISTS "Users can update their own reports." ON reports;
CREATE POLICY "Users can update their own reports." ON reports FOR UPDATE USING (true);
DROP POLICY IF EXISTS "Users can delete their own reports." ON reports;
CREATE POLICY "Users can delete their own reports." ON reports FOR DELETE USING (true);

-- Resources table
CREATE TABLE IF NOT EXISTS resources (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  disaster_id BIGINT REFERENCES disasters(id) ON DELETE CASCADE NOT NULL,
  name TEXT NOT NULL,
  type TEXT,
  status resource_status DEFAULT 'available',
  capacity INTEGER,
  current_occupancy INTEGER DEFAULT 0,
  location GEOGRAPHY(Point, 4326),
  details JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
CREATE INDEX IF NOT EXISTS resources_location_gix ON resources USING GIST (location);
CREATE INDEX IF NOT EXISTS resources_disaster_id_idx ON resources(disaster_id);

DROP TRIGGER IF EXISTS set_resources_timestamp ON resources;
CREATE TRIGGER set_resources_timestamp
BEFORE UPDATE ON resources
FOR EACH ROW
EXECUTE PROCEDURE trigger_set_timestamp();

ALTER TABLE resources ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Resources are publicly viewable." ON resources;
CREATE POLICY "Resources are publicly viewable." ON resources FOR SELECT USING (true);
DROP POLICY IF EXISTS "Users can create resources." ON resources;
CREATE POLICY "Users can create resources." ON resources FOR INSERT WITH CHECK (true);
DROP POLICY IF EXISTS "Users can update their own resources." ON resources;
CREATE POLICY "Users can update their own resources." ON resources FOR UPDATE USING (true);
DROP POLICY IF EXISTS "Users can delete their own resources." ON resources;
CREATE POLICY "Users can delete their own resources." ON resources FOR DELETE USING (true);

-- Cache table
CREATE TABLE IF NOT EXISTS cache (
  key TEXT PRIMARY KEY,
  value JSONB,
  expires_at TIMESTAMPTZ NOT NULL
);

-- Audit trail table
CREATE TABLE IF NOT EXISTS audit_trail (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  table_name TEXT,
  record_id BIGINT,
  action TEXT,
  user_id TEXT,
  data JSONB,
  timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- Geospatial function for nearby resources
CREATE OR REPLACE FUNCTION get_nearby_resources(
  disaster_id_input bigint,
  lat double precision,
  lon double precision,
  radius_meters double precision
)
RETURNS SETOF resources AS $$
BEGIN
  RETURN QUERY
    SELECT * FROM resources
    WHERE disaster_id = disaster_id_input
      AND ST_DWithin(location, ST_MakePoint(lon, lat)::geography, radius_meters);
END;
$$ LANGUAGE plpgsql;
